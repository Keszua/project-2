
# Trzeba sciagnac i zainstalowac dockera 
https://www.docker.com/get-started

# oraz WSL2  (taki linux na windowsa)
https://docs.microsoft.com/pl-pl/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package

# zakladanie konta na:
https://hub.docker.com/signup


# link do repo z kursu: 
https://github.com/pnowy/docker-course
#-------------------------------------------------------------------------------------------------
docker version
docker info       # liczba kontenerow i obrazow


docker            # wyswietli liste polecen

docker image pull nazwaObrau         # sciagniecie danego obrazu, bez uruchamiania
docker image pull nazwaObrau:mojTag  # sciagniecie danego obrazu + nadaj tag ale tez jakos koles sciagal odpowiednie wersje za pomocc tagu (film 18)
docker run
docker container run   # uruchomienie NOWEGO kontenera. Jezeli nie posiadamy obrazu, zostanie on sciagniety i uruchomiony
docker container run --publish 8080:80 --detach nginx  
#                      |       |    |    |      |- nazwa obrazu
#                      |       |    |    |- uruchomienie kontenera w tle
#                      |       |    |- port po stronie kontenera
#                      |       |- port, na ktorym kontener bedzie dostepny na naszym hoscie (zwykle localhost:8080)
#                      |- przekierowanie, -p [host-port:container-port]
#  zatrzymanie kontenera przez:  Ctrl+C

docker container run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d --name=myName docker.elastic.co/elasticsearch/elasticsearch:6.5.4
#                     |                         |                                   |           |                                             |- wersja albo tag
#                     |                         |                                   |           |- nazwa obrazu
#                     |                         |                                   |- nazwa kontenera
#                     |                         |- przekazanie zmiennej srodowiskowej
#                     |-[host-port:container-port]


#  uruchom w trybie interaktywnym z terminalem (wyjscie komenda exit)
docker container run -it nginx bash 
docker container start -ai idkontenera
docker container exec -it idkontenera bash  #  odpalenie konsoli na dzialajacym kontenerze
docker attach  [id lub nazwa kontenera]     #  odpalenie konsoli na dzialajacym kontenerze. Przerywamy Ctrl+C (cos było że nie polecane)


docker stop idkontenera
docker container stop idkontenera

docker container ls     #  wyswietli liste kontenerow URUCHOMIONYCH
docker ps               #  po staremu 
docker container ls -a  #  wyswietli liste wszystkich kontenerow, czyli nie uruchominych tez
docker image ls         #  lista obrazow

docker container start idkontenera  #  uruchominie istniejacego kontenera
docker rm idkontenera               #  usowanie kontenera
docker system prune --all           #  usowanie WSZYSTKICH obrazów jednym poleceniem:


docker container logs nazwaKontenera
docker container logs nazwaKontenera -f # ciagla obserwacja (zablokuje CLI)

curl localhost:8080  # zwroci kod HTML strony
curl localhost:9200  # zwroci JSON (jezli mamy odpalony elastic)

# curl - taka przegladarka z linii komend
curl -H "Content-Type: application/json" -XPOST "http://localhost:9200/docker/image/1" -d "{ \"name\" : \"elasticsearch\"}"
curl localhost:9200/docker/_search

#  do obserwowania, co sie dzieje w kolejkach
docker run -d --name rabbit-in-the-hole -p 8081:15672 rabbitmq:3-managment
#  po wejsciu na przegladarce, mozna sie zalogowac L: guest  H: guest


docker container top idkontenera      #  obserwacja procesow
docker container inspect idkontenera  #  wyswietla pelna konfiguracje kontenera (w formacie JSON)
docker container stats                #  "live striming" ogolny status wszystkich uruchominych kontenerow


#  -------------------------------------------------------------------------------------------------
docker network ls 
docker network inspect nazwaSieci

#  tworzenie sieci:
docker network create --driver=bridge mojaNowaNazwaSieci

#  uruchomienie kontenera "nginx" w konkretnej sieci (tutaj nazwa sieci to: skynet)
docker container run -d --network=skynet nginx
docker network connect skynet first      #  podlaczenie do sieci, kontenera first
docker network disconnect bridge first   #  odpiecie kontenera od domyslnej sieci (bo teraz byly dwie sieci)

#  Usuwanie sieci:
#  w pierszej kolejnosci trzeba odpiac lub usunac kontenery

#  DNS
#  Film 17 (Docker od podstaw)
#  Trzeba sprawdzic IPAddress  (polecenie docker network inspect ...)
#  Endpoint informujacy o stanie serwisu: (w konsoli linuxa)
curl http://172.17.0.3:8080/actuator/health

#  do wywyłania postów curlem:
curl -X POST http://localhost:3000/parametr


#  urzycie opcji link ... na przykladzie polaczenia do bazy MSQL
docker run --name wordpressdb -e MYSQL_ROOT_PASSWORD=wordpress -e MYSQL_DATABASE=wordpress -d mysql:5.7
docker run -e WORDPRESS_DB_PASSWORD=wordpress -d --name wordpress --link wordpressdb:mysql -p 80:80  wordpress:5-php7.2
#                                   |                   |                |           |        |- port zewnetrzny dla przegladarki
#                                   |                   |                |           |- wewnetrzny alias, domyslnia nazwa dla bazy danych to mysql
#                                   |                   |                |- nazwa kontenera
#                                   |                   |- nazwa kontenera
#                                   |- nazwa bazy danych


# konfiguracja PrestaShop z bazą przez zmienną środowiskową (nie przez link)
# create a network for containers to communicate
$ docker network create prestashop-net
# launch mysql 5.7 container
$ docker run -ti --name some-mysql --network prestashop-net -e MYSQL_ROOT_PASSWORD=admin -p 3307:3306 -d mysql:5.7
# launch prestashop container
$ docker run -ti --name some-prestashop --network prestashop-net -e DB_SERVER=some-mysql -p 8080:80 -d prestashop/prestashop
# UWAGA! Gdy zmienie nazwę bazy, to tez trzeba ta nazwe zmienic w DB_SERVER=some-mysql


Nazwa klepu: Karol_test
Imie: Karol
Nazwisko: M
Email: k.michalczyk@humansoft.pl
H 12345678

#  -------------------------------------------------------------------------------------------------
#  Budowanie obrazow

docker image history nazwaObrazu   # mozna podejzec, kiedy i z jakich warstwy zostal stworzony obraz
docker image inspect idKontenera   # wyswietla pelna konfiguracje obrazu (w formacie JSON)

#  nadawanie nowego tagu
docker image tag nazwa:aTagiem nazwaKontaDockerHub/nazwa
#                                                   |- nazwa z ewentualnym tagiem

#  wyslanie obrazu na wlasne repozytorium:
#  trzeba byc zalogowanym, te same dane co na https://hub.docker.com/ :
docker login 
docker image push nazwaKontaDockerHub/nazwaObrazu:zTagiem
docker logout #  jezli chcemy sie wylogowac 

#  pobranie ze swojego repo
docker image pull nazwaKontaDockerHub/nazwaObrazu:zEwentualnymTagiem

#  tworzenie obrazu na podstawie kontenera:
docker container commit idKontenera nazwaKontaDockerHub/nazwaObrazu:zTagiem


#  -------------------------------------------------------------------------------------------------
#  Dockerfile
#  tworzenie kontenera z wykorzystaneim pliku Dockerfile
#  w filmie 21 koles pokazuje plik Dockerfile gdzie definiuje sie, jak przerobic i skonfigurowac obraz
https://docs.docker.com/engine/reference/builder/
#  trzeba bylo konsole otworzyc w folderze w ktorym jest plik Dockerfile
docker image build -t nowaNazwaObrazu:tag .


#  Przykład pliku:
FROM node:10-slim
WORKDIR /app             #  Create app directory WORKDIR to tak jak RUN cd /app   Dla noda: /app   dla nginx: /usr/share/nginx/html

COPY package*.json ./    #   Kopiuje pliki Z lokalnego host DO obrazu

RUN npm install --only=production   #   RUN wykonuje komendę

COPY . .   #   Kopiuj wszystko z folderu, oprucz elementów zdefiniowanych 

EXPOSE 3000  #  port do nasłuchu

ENV NODE_ENV production  #   Zmienne srowowiskowe przekazane do obrazu

#   ENTRYPOINT [ "entrypoint.sh" ]  Gdy nie podamy Entrypoint, wywoła się polecenie domyślne: /bin/sh -c
#   "entrypoint.sh" - to plik, który powninen być obok Dockerfile
#   CMD ["trafik"] specyfikuje argument, jaki będzie przekazywany do ENTRYPOINTa
CMD ["node", "app.js"]

LABEL   #  - metadane do obrazu



#--------------------------------------------------------------------------------------------------
#  Volumes
docker volume ls     #  wyświetl wszytkie volumeny
docker volume prune  #  usuwanie wszytkie volumeny


#  aby sprawdzić czy volumen jest podpięty, wywołac polecenie:
docker container inspect idKontenera
#  w "Mounts": [    powinien być "Type": "volume"  z jego nazwą (id)


# przykład ze strony https://adamtheautomator.com/docker-windows/
# Parametr --mount wymaga trzech argumentów; 
docker run --mount type=bind,source="E:/",target=/home/TEST -it alpine
#                  |         |            |-ścieżka do katalogu docelowego. Ścieżka docelowa będzie dowiązaniem symbolicznym w kontenerze.
#                  |         |-ścieżka do źródłowego katalogu hosta
#                  |-typ montowania


#  aby do kontenera podpiąć istniejący wolumen:
docker container run -d --mount 'src=idVolumenu,dst=/appdata' -p 3000:3000 nazwaObrazu

#  starsza metoda podpinania volumenu, przez literę -v
docker container run -d -v idVolumenu:/appdata' -p 3000:3000 nazwaObrazu

#  uruchomienie kontenera i stworzenie volumenu z "ludzką" nazwą
docker container run -d --mount 'src=nazwa-volumenu,dst=/appdata' -p 3000:3000 nazwaObrazu

# przykład z filmu https://www.youtube.com/watch?v=p2PH_YPCsis&list=PLy7NrYWoggjzfAHlUusx2wuDwfCrmJYcs&index=12
docker run -v /home/mount/data:/var/lib/mysql/data
#              |                |- sciezka do kataogu w maszynie (wnętrze kontenera)
#              |- Host Volumes. Jezeli tego nie podam, doker wygeneruje losową nazwę: /var/lib/docker/volumes/random-hash/_data

# Sztuczka na kopiowanie volumenu:
docker container run --rm -it -v staraNazwa:/from -v nowaNazwa:/to alpine ash -c "cd /from; cp -av . /to"


# Tworzenie kopii zapasowej danych Jenkinsa z kontenera do hosta https://adamtheautomator.com/jenkins-docker/
docker cp <container id>:/path/in/container /path/in/host
# przyklad:
docker cp my-jenkins-1:/var/jenkins_home ~/jenkins_backup


#--------------------------------------------------------------------------------------------------
#  Bind mounnts
#  coś jak Volumes dla wersji developerskiej (starsze podejście)

#  uruchamiamy kontener z flagą -v
docker run -d -p 80:80 -v $(pwd):/usr/share/nginx/html nginx
#  w przypadku windowsa:
docker run -d -p 80:80 -v //c/User/przemek/data:/path/data
#  u mnie zadziałało tak: (w konsoli bash)
docker run -d -p 80:80 -v //d/Karolek/Docker/dockerfiles/nginx-simple:/usr/share/nginx/html nginx



#--------------------------------------------------------------------------------------------------
#  Docker compose
#  Definicja w pliku: docker-compose.yml  #  może być inna nazwa, ale będzie trzeba ją podać w komendzie

#  ogólny pos:
version: '3.7'

services:               # definicja kontenerów (odpowiednik docker container run)

  servicename1:         # nazwa serwisu (np. "db" lub "elasticsearch" ), będzie to także DNS serwisu w sieci
    image: mysql:5.7    # nazwa obrazu którego użyć do uruchomienia kontenera (opcjonalny w przypadku użycia build)
    environment:        # zmienne środowiskowe przekazywane do kontenera przy jego uruchomieniu
      KEY: value
      KEY2: value2
      # - KEY=value
      # - KEY2=value2
      # MYSQL_ROOT_PASSWORD: somewordpress
      # MYSQL_DATABASE: wordpress
      # MYSQL_USER: wordpress
      # MYSQL_PASSWORD: wordpress
    env_file:           # zmienne środowiskowe
      - a.env           # zmienne środowiskowe z pliku
    command:            # nadpisanie domyślnego polecenia kontenera/obrazu
    volumes:            # odpowiednik -v z docker run (wsparcie zarówno starszej jak i nowszej składni)
      - db_data:/var/lib/mysql
  
  servicename2:         # kolejny serwis (np: "wordpress")
    depends_on:         # okreslamy zależność pomiędzy kontenerami. Ten jest zależny od "db", czyli uruchomi się, jak ten poprzedni już będzie działał
      - db
    image: wordpress:latest

    ports:
      - "8000:80"
    environment:
      WORDPRESS_DB_HOST: db:3306   # adres serwera i port. Adres przez DNS jest taką nazwą jak nazwa kontenera
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress


volumes:                # definicja wolumenu (docker volume create)
  db_data:              # przyklad z nazwa volumenu (pusta nazwa po dwukropku (chyba))

networks:               # definicja sieci (docker network create)


Przykałdowy wordpress
localhost:8000
Użytkownik: karol
H: karol


# Aby uruchomić:
# W konsoli upewnij sie ze jestes na dobrej sciezce i uruchom poleceniem:
docker-compose up       # tworzy i uruchamia
# jeśli nie uruchomiony w trybie -d, to konczymy Ctrl+C
docker-compose start    # uruchomienie stworzonych kontenerów
# jeśli w trybie -d, zatrzymujemy komendą:
docker-compose stop
docker-compose down     # zatrzymanie i usunięcie wszytkich kontenerów i zależności

docker-compose ps       # liste kontenerów
docker-compose top      # obserwacja procesów
docker-compose logs     # obserwacja logów


#--------------------------------------------------------------------------------------------------
#Przykład pliku dla App Service i MySQL z kursu: https://docs.microsoft.com/pl-pl/visualstudio/docker/tutorials/use-docker-compose

version: "3.7"

services:
  # docker run -dp 3000:3000 -w /app -v ${PWD}:/app --network todo-app -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=secret -e MYSQL_DB=todos node:12-alpine sh -c "yarn install && yarn run dev"
  # Definiowanie App Service.
  app:                                 # Nazwa serwisu (dowolna, ale ona będzie aliasem sieciowym)
    image: node:12-alpine              # wpis usługi i obraz kontenera
    command: sh -c "yarn install && yarn run dev"   
    ports:
      - 3000:3000                      # zmigrowane polecenie: -p 3000:3000
    working_dir: /app                  # zmigruj katalog roboczy ( -w /app )
    volumes:
      - ./:/app                        # mapowanie woluminów ( -v ${PWD}:/app )  Docker Compose używa ścierzek względnych
    environment:                       # zmienne środowiskowe
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  # docker run -d --network todo-app --network-alias mysql -v todo-mysql-data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DATABASE=todos mysql:5.7
  # Definiowanie usługi MySQL
  mysql:                               # nazwa: mysql
    image: mysql:5.7                   # określ obraz do użycia.
    volumes:                           # zdefiniuj mapowanie woluminów.
      - todo-mysql-data:/var/lib/mysql # określić punkt instalacji w konfiguracji usług
    environment: 
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos


volumes:                          
  todo-mysql-data: 

# Uruchamianie stosu aplikacji:
# Najpierw upewnij się, że nie są uruchomione żadne inne kopie aplikacji i bazy danych ( docker ps i docker rm -f <ids> ).
# Uruchom stos aplikacji przy użyciu polecenia docker-compose up  Dodaj -d flagę , aby uruchomić wszystko w tle. Alternatywnie możesz kliknąć prawym przyciskiem myszy plik Compose i wybrać opcję Utwórz dla VS Code bocznym.
docker-compose up -d

docker-compose logs -f       # Przyjrzyj się dziennikom za pomocą polecenia 
docker-compose logs -f app   # dziennik dla konkretnej usługi

docker-compose down          # zatrzymanie kontenerów i usówanie sieci


#--------------------------------------------------------------------------------------------------
# Przykład działającej konfiguracji PrestaShop:
version: '3.9'

services:
    prestashop_mysql:
        # image: mysql:5.7
        image: prestashop-db:5.7_3
        container_name: prestashop-db
        command: --default-authentication-plugin=mysql_native_password
        environment:
            MYSQL_DATABASE: prestashop
            MYSQL_ROOT_PASSWORD: admin
        volumes:
            # - ./.docker/data/mysql/:/var/lib/mysql
            # - ./.docker/logs/mysql/:/var/log/mysql
            - db_data:/var/lib/mysql
        ports:
            - 3307:3306
        networks:
            - presta-net
        
    prestashop:
        # image: prestashop/prestashop:1.7
        image: prestashop:1.7_3
        container_name: prestashop
        ports:
          - 8080:80
          - 2202:2202
        environment:
            DB_SERVER: prestashop_mysql
            MYSQL_HOST: mysql
            MYSQL_USER: root
            MYSQL_PASSWORD: admin
            MYSQL_DB: prestashop
        networks:
            - presta-net

networks:
  presta-net:
    external: false #needs to be created by other file
    driver: bridge
    name: prestashop-net

volumes:
  db_data:
    name: docker_test1_db_data


#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------

https://github.com/veggiemonk/awesome-docker

#  poczytac o Kubernetes znany też jako: K8s
https://kubernetes.io/


Instalacja Minikube : https://www.youtube.com/watch?v=X48VuDVv0do&t=453s   40:23


https://ihermes.humansoft.pl/login


#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
przez SSH:
docker1

portainer.io
https://10.10.10.186:9443/#!/home
admin  
docker123


Nginx Proxy Manager
http://10.10.10.186:81/
m.zalecki@humansoft.pl
docker123


#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------

# jakiś filmik, jak stworzyć front w React i backend w Node.js  https://www.youtube.com/watch?v=-pTel5FojAQ

# W jednym folderze normalnie instaluje React
npx create-react-app forntend
# Robie drugi folder backend (na tym poziomie co cały React). 
# Wchodze do tego folderu, tam wywołuje 
npm init
# powatanie plik package.json, do kturego dopisuje zalezności (stare scripts usunąć):
{
  ...
  "dependencies": {
    "express": "4.16.3",
    "pg": "8.0.3",
    "cors": "2.8.4",
    "nodemon": "1.18.3",
    "body-parser": "*"
  },
  "scripts": {
    "dev": "nodemon",
    "start": "node index.js"
  }
}
# wywołujemy instalecję, aby zalezności się zainstalowały:
npm i

# Utwórz plik keys.js ze zmiennymi potrzebnymi dla kontenera
# Zawartość pliku:
module.exports = {
    pgUser: process.env.PGUSER,
    pgHost: process.env.PGHOST,
    pgDatabase: process.env.PGDATABASE,
    pgPassword: process.env.PGPASSWORD,
    pgPort: process.env.PGPORT,
}
# Utwórz plik index.js z prostym serwerem

#  uruchomienie serwera poleceniem:
npm run dev


# FRONT w package.json reacta do zalezności dopisujemy:   Film 9:20  https://www.youtube.com/watch?v=-pTel5FojAQ
{
  ...
  "dependencies": {
    ...
    "axios": "0.18.0",
    "react-router-dom": "4.3.1"
  },
}

# Projekt reacta odpalam przez:
npm run start


# Aby wsadzić projekt reacta  do kontenera, trzeba dodac plik (na poziomie .gitignore) Deckerfile.dev
# Zawartość pliku:   Film YT 18:30  https://www.youtube.com/watch?v=-pTel5FojAQ
FROM node:14.14.0-alpine
WORKDIR /app
COPY ./package.json ./
RUN npm i
COPY . .
CMD ["npm", "run", "start"]

# Buduje obraz projektu:
docker build -f Dockerfile.dev -t stylerhun/multi-client .

# Odpalam kontener:
docker run -it -p 4002:3000 --name=P1Front stylerhun/multi-client


# Teraz tworze kontener dla backendu, plik Dockerfile.dev jest podobny:
FROM node:14.14.0-alpine
WORKDIR /app
COPY ./package.json ./
RUN npm i
COPY . .
CMD ["npm", "run", "dev"]

# Buduje obraz projektu:
docker build -f Dockerfile.dev -t stylerhun/multi-server .

# Odpalam kontener:
docker run -it -p 4003:5000 --name=P1Back stylerhun/multi-server


#--------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
  #   #         #                                           #  
  #  #          #                                           #  
  # #    #   #  ###     ###   # ###  ####    ###    ###   #####
  ##     #   #  #   #  #   #  ##     #   #  #   #  #        #
  # #    #   #  #   #  #####  #      #   #  #####   ###     #
  #  #   #   #  #   #  #      #      #   #  #          #    #
  #   #   ####  ####    ###   #      #   #   ###    ###      ##
#--------------------------------------------------------------------------------------------------
KUBERNEST

kubectl version  # sprawdzenie, czy jest zainstalowany kubernest i w jakiej wersjii

# tworzenie podów zdefiniowanych w folderze k8s ( trzeba być na takim poziomi, żeby po wpisaniu ls widac było folder 'k8s')
kubectl apply -f k8s

kubectl get pods
kubectl get services  # lista serwisów z IP oraz portami

# szyfrowanie haseł:
kubectl create secret generic pgpassword --from-literal PGPASSWORD=12345test

# odczyt tokenów z hasłami:
kubectl get secret

# Pogubiłem się na Filmie YT 17:20 https://www.youtube.com/watch?v=OVVGwc90guo
# Nie znalazłem linku instalacyjnego, takiego jak koles z filmu.

kubectl get pv

kubectl delete -f k8s







